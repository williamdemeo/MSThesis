36

sampl from the stationary distribution are not quickly attainable. Furthermore, we are trying to
ﬁgure out how long it will take for observations from the simulated chain to represent samples from
the stationary distribution. Second, the method we have developed depends solely on covariances
of our observable which we estimate from the data. produced by the simulations. However, such
estimates require that the data come from the stationary distribution. Therefore, we must discard a
number of observations before using the data to estimate covariances. The number of observations
to discard depends on how long must we wait until we have data from the stationary distribution,
and we are back where we started — almost. When employing our procedure, we can discard a
conservative (very large) number of observations and perform our analysis, deriving a bound on
the convergence time. Then, in all future studies, we will know how much data should be discarded
before samples come (approximately) from the stationary distribution.

In considering what observable to use on the state space described above, perhaps the
most obvious is simply the number of nodes in the on position (i.e. the number of +l’s). Recalling
that 0, (k) = i1 denotes the position (on or off) of the kth node when the system is in state j, this

observable is deﬁned by,
«M = zxca.-ac) = +1). 1 = 1.---.ISl
I:

where X is the indicator function. The program ising.m simulates the Markov chain, computes the
values of this observable (as well as the number of 1’s squared) and writes it to a ﬁle called phi . dat.
The program then proceeds to compute the ﬁrst few Lanczos coefficients using covariances produced
by Matlab, so that we can check them against the rults we get from the 1anczos.c program,
which we now describe.

The lanczos .c program (listed in the Appendix along with its dependencies) implements
the recursive relations described in section 4.2 to compute the Lanczos coefﬁcients by the new

method. It accepts input from the user specifying any observable, any number of iterations, and any

