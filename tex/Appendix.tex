% 42.txt
Appendix: computer programs

Z Hatlab code ising.m

Z
Z Written by William J. De Meo on 12/15/97

2 last modified 1/10/98

Z Inputs:

2 d = number of nodes of the ising lattice (e.g. d=100)
Z n = number of iterations (e.g. n=1000)

Z beta = Annealing schedule (e.g. beta = 2,

1 when beta -> 0 will always go to nee state
Z vhen beta -> infty will never go to state of higher energy)
Z

X = zeros(d,1);
Energy = zeros(n,1);

Ave=0;

X Initialize using hot start
for i=1:d,

if rand < .5

x(i) = -1;

else

X(i) = 1;

end
end

Z Initialize at state of high energy (not used)

if 0
X(1:2:d-1)=1;
X(2:2:d)=—1;
and

Z Initialize energy

H=0;

for i=1:(d-1)

H = H - X(i)*X(i+1);
end

2 Initialize observable
phi = zeros(n+1,1);

for i=1:d
if X(i) == 1
phi(1)= phi(1)+1;
end

end

42

% 43.txt
43

for j=1:n

site=0;
while site==

site = round(rand#d);
end
Z Compute new energy (with new X(site) = —x(site)):
if site ==

Hnew = H + 2:x(1)~x(2);
elseif site == d

Hnew = H + 2*X(d)tX(d-1);
else

Hnew = H + 2*X(site)*(X(site-1) + X(site+1));
end

Z Change to new state in two ways:
X with probability 1/2, flip the switch
if rand < .5
if (Hnew <= H) I (rand < exp(-beta*(Hnew-H)))
x(site) = -x(site);
H = Hnew;
Z Compute new value of observable
if X(site) -= 1
phi(j+1) = phi(j) + 1;

else
phi(j+1) = phi(j) — 1;
end
else phi(j+1)=phi(j);
end
else phi(j+1)=phi(j);
end
Energy(j) = H;
end
p1ot(Energy)

% A second observable
phi2 = zeros(n+1,1);
for i=1:n+1

phi2(i) = phi(i)*phi(i);
end

Z Write first observable to phi.dat:

fid = fopen(’/quean.a/masters/deme5025/research/nyuthesis/programs/c/phi.dat’,’w’);
fprintf(fid,’%f\n’,phi);
fc1ose(fid);

Z Write second observable to phi2.dat:
fid = fopen(’/quean.a/masters/deme5025/research/nyuthesis/programs/c/phi2.dat’,’w’);

% 44.txt
fprintf(fid,’%f\n’,phi2);
fc1ose(fid);

1 Compute a few Lanczos coefficients by new method
START=1001;

V1=zeros(2);

C1=zeros(2);

C2=zeros(2);

C3=zeros(2);

V1 = cov(phi(START:n+1),phi(START:n+1));

V1 = V1(1,1)5

C1 = cov(phi(START:n),phi(START+1:n+1));
C1 = C1(1,2);

C2 = cov(phi(START:n-1),phi(START+2:n+1));
C2 = C2(1,2);

C3 = cov(phi(START:n-2),phi(START+3:n+1));

C3 = C3(1,2);

a1pha1 = C1/V1;

betai = sqrt(C2/V1 ' (C1/V1)‘2);

a1pha2 = (1/(beta1’2))*(C3/V1 - 2*a1pha1*(C2/V1) + a1pha1‘3);

T1 = Ealphal betal; betal a1pha2]

v1 = cov(phi2(START:n+1),phi2(START:n+1));
v1 = v1(1,1);

c1 = cov(phi2(START:n),phi2(START+1:n+1));
c1 = c1(1,2);

c2 = cov(phi2(START:n—1),phi2(START+2:n+1));
c2 = c2(1,2);

c3 = cov(phi2(START:n-2),phi2(START+3:n+1));
c3 = c3(1,2);

alphal = C1/V1;
betal = sqrt(C2/V1 - (C1/V1)‘2);
a1pha2 = (1/(beta1‘2))#(C3/V1 - 2ta1pha1*(C2/V1) + a1pha1”3);

T2 = [a1pha1 betai; betal a1pha2]

fid = fopen(’Tmats.dat’,’v’);
fprintf(fid,’%f\n',T1);
fprintf(fid,’%f\n’,T2);
fc1ose(fid);

ZZZ end ising.m

44
% 45.txt
\% Matlab code tpm.m for generating transition probability matrix
Z and computing its eigenvalues directly

1

Z Written by Hilliam J. De Heo on 1/10/98

1

Z Inputs:

Z d = number of nodes of the ising lattice (e.g. d=10)

Z beta = Annealing schedule (e.g. beta - 2,

1 when beta -> 0 will always go to new state
1 when beta -> infty will never go to state of higher energy)
2

disp(’bui1ding proposition matrix...’)

states = 2‘d;

A = 0;

for i=0:(d-1)

E=eye(2”i);

A = [A E;E A];

end

B = .5#eye(states);

A = B + .5-(1/d)*A;

2 our modified Glauber dynamics requires the B and the .5¥(1/d)

disp(’...done’)

1 display pattern of nonzero entries
1 spy(A)

Z check that all row sums are 1
check=O;
for i=1:states

check = check + (not(sum(A(i,1:states))<.99));
end
1 if not all rows sum to 1, print check = (# of rows with sum=1)
if not(check==states)

check

error(’Row sums are not all 1’)
end

Z construct matrix of states
E = zeros(d,states);
f1ip=-1;
for i=1:d
for j=1:2‘(i-1):states
flip = -1*f1ip;
for k=0:2“(i-1)

45

% 46.txt
E(i,j+k) = flip;
and
end
end
E=E’;

Z display first 64 states
Z E(1:64,:)

Z compute energy of each state
H = zeros(states,1);
for i=1:states

for j=1:d-1
H(i) = H(i) - E(i,j)tE(i,j+1);
end
end

disp(’building Hetropolis transition matrix...')

for i=1:states
for j=i+1:states
if not(A(i,j)==0)
if(H(j)>H(i))
alt = A(i,j)t(1-exp(-beta*(H(j)-H(i))));
A(i,i) I A(i,i)+a1t;
A(i,j) = A(i,j)-alt;
elseif(H(j)<H(i))
alt = A(j,i)t(1-exp(—beta#(H(i)-H(j))));
A(j,j) = A(j,j)+a1t:
A(j,i) = A(j,i)-alt;
end
end
end
end

disp(’...done’)

check=0;
for i=1:states

check = check + (not(sum(A(i,1:states))<.99));
end

Z if not all rows sum to 1, print check = (# of rows with aum=1)

if not(check==states)

check

error(’Row sums are not all 1’)
end

46

% 47.txt
47

disp(’computing eigenvalues of tpm...’)
cput = cputime;

evals = eig(A);

ecput = tputime - cput;

disp(’the CPU time (in secs) for computing eigenvalues of tpm: ’)

ecput
ZZZ end tpm.m

/¥#*##¥###*##*#l####¥#‘###$ﬂ###ﬁi##*U3*#**#*##**##¥***ll¥#*##¥ii

* 1anczos.c main program for computing Lanczos coefficients *
3 #
* Created by William J. De Heo #
t on 1/7/98 *
# Last modified 1/10/98 #

*¥#######**3It¥*#¥¥¥#**##**¥##¥#####**####*#*###*##**###¥##*##*/

#inc1ude <stdlib.h>
#include <stdio.h>
#include <math.h>
#inc1ude "prototypes.h"

/# Machine constants on dino (Sun Ultra 1 at Courant) t/
#define HACHEPS 1.15828708535533604981e-16

#define SQRTEPS 1.07623746699106147048e-08

ﬂdefine HAX_NAH 100

void read_name(char *);

/* Prototypes from the file functions.c ¥/

double a1pha(int j);

double betasq(int j);

double form1(int j, int k);

double form2(int j, int k);

double moment(doub1e ‘data, long n, double tave, double tvar, double tcov, long k);

/# external variables to be used by functions */
double *phi,tcov, tvar, tave;

% 48.txt
main()

{

char tfilename;

FILE *ofp;

double temp=O, *T;

long i, j, nrou, nlanc, START;
int f1ag=O;

filename = cma11oc(HAx_NAHE);

printf("\nName of file containing observed values: “);

read_name(fi1ename);

printf(“\nTota1 number of observations in file (iterations):

scanf(“Zu”,&nrov);

printf(“\nNumber of leading observations to discard: “);

scanf("Zu",&START);

printf("\nNumber of Lanczos coefficients desired: “);

scanf("%u",&n1anc);

vhi1e(2*n1anc > nrow—START)

{
printf("\nNot enough data for that many coefficients.\n“);
printf("\nEnter a smaller number of Lanczos coefficients: “);
scanf("Xu“,&n1anc);

}

II);

phi = dma11oc(nrow);
cov=dma11oc(2#n1anc);
var=dma11oc(1);
ave=dma11oc(1);

T = dma11oc(n1anc#n1anc); for(i=0;i<n1anc;i++) T[i]=(doub1e)0;

/* observable phi is stored contiguously column-wise (e.g. by HATLAB) t/
mat1abread(phi, nrow, 1,fi1ename);

/* send the observable, offset by START */
moment(phi+START,nrou-START,ave, var, cov,2*n1anc-1);

/* First column of T */

T[0] = a1pha(1);
if((temp=betasq(1))>HACHEPS*10)
{

T[1]=sqrt(temp);

/* General column of T */

J'=2:

for(i=1;i<n1anc-1, f1ag==O;)
{

T[itn1anc+i-1]=sqrt(betasq(i));

48

main()

{

char tfilename;

FILE tofp;

double temp=0, #T;

long i, j, nrow, nlanc, START;
int f1ag=0;

filename = cma11oc(HAx_NAH);

princf("\nName of file containing observed values: “);
read_name(fi1ename);

printf("\nTota1 number of observations in file (iterations): “);
scanf("2u“,&nrow);

printf("\nNumber of leading observations to discard: “);
scanf("Zu",&START);

printf("\nNumber of Lanczos coefficients desired: “);
scanf("%u“,&n1anc);

whi1e(2*n1anc > nrou-START)

{
printf("\nNot enough data for that many coefficients.\n");

printf("\nEnter a smaller number of Lanczos coefficients: “);
scanf("Zu",&n1anc);
}

phi = dma11oc(urow);
cov=dma1loc(2*n1anc);
var=dma11oc(1);
ave=dma11oc(1);

T = dma11oc(n1anc*n1anc); for(i=0;i<n1anc;i++) T[i]=(doub1e)O;

/* observable phi is stored contiguously column-wise (e.g. by HATLAB) */
mat1abread(phi, nrov, 1,fi1ename);

/* send the observable, offset by START #/
moment(phi+START,nrov-START,ave, var, cov,2*n1anc-1);

/# First column of T */

T[0] = a1pha(1);
if((temp=betasq(1))>HACHEPS#10)
{

T[1]=sqrt(temp);

/* General column of T */

J‘=2:

for(i-1;i<n1anc-1, f1ag==0;)
{

T[i*nlanc+i-1]=sqrt(betasq(i));

48


% 49.txt
T[i*n1anc+i] = a1pha(i+1);
if((temp = betasq(i+1))>HACmEPS#10)
{

T[i#n1anc+i+1] = sqrt(temp);

i++;
}
else

f1ag=1;

}

/t Last column */
if(f1ag!=1 it ((temp= betasq(n1anc-1))>HACHEPSt10))

{
T[n1anc#n1anc-2] = sqrt(temp);
T[n1anctn1anc-1] = a1pha(n1anc);
printf("\nbeta(1) = %1f\nbeta(Zd) = Zlf (last beta)",
T[1],(nlanc-1),T[nlanc*n1anc-2]);
}
else
{
printf("\nApproximate invariant space reached at step %d.",i);
printf("\nbeta(1) = Z1f\nbeta(Zd) = Zlf (last accurate beta)“.
T[1],i,T[itn1anc+i—1]);
printf("\nbeta(Zd)“2: Zlf (first spurious resu1t)“,i+1,temp);
}

printf("\nThe matrix T is: \n");
matprint(T,n1anc,n1anc);

}

else

{

printf("\nmain(): Approximate invariant space reached at first step.“);

49

printf("\na1pha(1) - Z1f\nbeta(1)”2: Zlf (first spurious result)“, T[O], temp);

}
ofp = fopen("Tmat.m","v“);
check(ofp);
mat1aburite(T,n1anc,n1anc,ofp);
fc1ose(ofp);
}
void read_name(char tname)
{
int c, i = 0;
while ((c = getchar()) != EOF it c != ’ ’ it c !- ’\n’)
name[i++] = c;
name[i] = ’\0’;
}

/#t* end 1anczos.c *#*/

% 50.txt
50

/llnkttttttttinlntint*1!!!##1##!ttitilltit###t¥#tt¥ttItt####t#ttII=##mlltttt

* functions.c functions required by 1anczos.c t
# t
* Created by Hilliam J. De Meo #
* on 1/7/98 *
t Last modified 1/10/98 :

¥¥##¥$¥##¥¥#$¥¥¥###¥¥$*I#****#**####*######¥#¥#¥#$#¥¥#l¥**#****/

#inc1ude <math.h>

#define START 1000

#define ITER 10000

/t Machine constants on dino (Sun Ultra 1 at Courant) */

#define HACHEPS 1.15828708535533604981e-16

#define SQRTEPS 1.07623746699106147048e-O8

double a1pha(int j);

double betasq(int j);

double form1(int j, int k);

double form2(int j, int k);

double moment(doub1e tdata, long n, double tave, double tvar, double tcov, int k);

/t external variables to be used by functions */
double *phi,tcov, *var, tave;

double alpha(int j)
{

/* alpha is never called with j < 1 */
if(j==1)
return
form1(1,1);
else if(j>1)
return
((doub1e)1/betasq(j-1))*
(form1(j-1,3) — pou(a1pha(j-1),3)
- 2 * (alpha(j-1)#betasq(j-1) + sqrt(betasq(j-2))#form2(j-1,2))
+ betasq(j-2));
}

double betasq(int j)

{
if(j==0)
return (doub1e)O;
else if(j>0)
return (form1(j,2) - pow(a1pha(j),2) - betasq(j-1));
}

double form1(int j, int k)
{

% 51.txt
51

double form14,alphal,alpha1sq,form12,form13;
if(j==0)

return (doub1e)0;
else if(j==1)
{

/# printf("\nvar = %1f, cov(%d) = %1f \n“,*var,k,cov[k]);t/

return (cov[k])/(*var); /* the only real value */
}
else if(j>1)
{

return ((double)1/betasq(j-1))

* ( form1(j-1,k+2)
+ pow(a1pha(j-1),2)*form1(j-1,k)
+ 2t(a1pha(j-1) t sqrt(betasq(j-2)) * form2(j-1,k)
- a1pha(j-1)*form1(j-1,k+1)
- sqrt(betasq(j—2))#form2(j-1,k+1) )
+ betasq(j-2)*form1(j-2,k)):
}
}

double form2(int j, int k)
{
/* form2 is never called with j < 1 */
if(j==1)
return (doub1e)0;
else if(j>1)
return
(pov(betasq(j-1),—.5)) 3
(form1(j-1,k+1) - a1pha(j-1)*form1(j-1,k)
- sqrt(betasq(j-2)) # form2(j—1,k));
}

/* moment() function for computing var and cov(k)
arguments:
data = a nxi array of doubles
n = length of data[]
ave =(on exit)= the average of data[]
var =(on exit)= the variance of data[]
cov =(on exit)= the covariance of data[i] and data[i+j] for i-1,...,k
k = the max lag for cov above
*/
double moment(double tdata, long n, double tave, double tvar, double tcov, int k)
{
/* Centered about data[0] algorithm: #/

long i,j;
double avel, ave2;

% 52.txt
52

*ave=O;tvar=0; ave1=ave2=O;
for(j=0;j<=k;j++)
cov[j]=0;

for(i=1;i<n;i++)
{
rave += (data[i] - data[0]);
tvar += (data[i] - data[0])#(data[i] - data[0]);
}
tvar /= (doub1e)(n-1);
Ivar -= (((*ave)/(doub1e)n) * ‘(*ave)/(doub1e)(n-1)));
/# *ave = ((*ave)/(doub1e)n) + data[0]; <- that’s the true average (not needed)*/

for(j=0;j<=k;j++)
{

for(i=0;i<(n-j);i++)

{

avel += (data[i] - data[0]);
ave2 += (data[i+j] - data[0]);
cov[j] += (data[i] - data[0])*(data[i+j] — data[0]);

}

avel/=(doub1e)(n-j); ave2/=(doub1e)(n-j);

cov[j] = ((cov[j] - (double)(n-j)tave1¢ave2)/(double)(n-j-1));
}

}

/trt end funccions.c ###/


